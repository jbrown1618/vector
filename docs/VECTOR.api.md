## API Report File for "@josh-brown/vector"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export type ApproximationFunction<S> = (input: Vector<S>) => S;

// @public
export type ApproximationFunctionTemplate<S> = (coefficients: Vector<S>) => ApproximationFunction<S>;

// @public
export abstract class ArrayMatrix<S = number> implements Matrix<S> {
    // @internal
    protected constructor(data: MatrixData<S>);
    add(other: Matrix<S>): Matrix<S>;
    adjoint(): Matrix<S>;
    apply(vector: Vector<S>): Vector<S>;
    abstract builder(): MatrixBuilder<S, Vector<S>, Matrix<S>>;
    combine(other: Matrix<S>, combineEntries: (a: S, b: S) => S): Matrix<S>;
    equals(other: Matrix<S>): boolean;
    forEach(cb: (value: S, i: number, j: number) => void): void;
    getColumn(j: number): Vector<S>;
    getColumnVectors(): Vector<S>[];
    getDiagonal(): Vector<S>;
    getEntry(i: number, j: number): S;
    getNumberOfColumns(): number;
    getNumberOfRows(): number;
    getRow(i: number): Vector<S>;
    getRowVectors(): Vector<S>[];
    getShape(): MatrixShape;
    getSparseData(): Map<number, Map<number, S>>;
    map(entryFunction: (entry: S, rowIndex: number, columnIndex: number) => S): Matrix<S>;
    multiply(other: Matrix<S>): Matrix<S>;
    abstract ops(): ScalarOperations<S>;
    scalarMultiply(scalar: S): Matrix<S>;
    set(i: number, j: number, value: S): Matrix<S>;
    toArray(): S[][];
    trace(): S;
    transpose(): Matrix<S>;
    abstract vectorBuilder(): VectorBuilder<S, Vector<S>>;
}

// @public
export abstract class ArrayVector<S = number> implements Vector<S> {
    // @internal
    protected constructor(data: VectorData<S>);
    add(other: Vector<S>): Vector<S>;
    abstract builder(): VectorBuilder<S, Vector<S>>;
    combine(other: Vector<S>, combineEntries: (entry1: S, entry2: S) => S): Vector<S>;
    equals(other: Vector<S>): boolean;
    forEach(callback: (entry: S, index: number) => void): void;
    getDimension(): number;
    getEntry(index: number): S;
    getSparseData(): Map<number, S>;
    innerProduct(other: Vector<S>): S;
    map(valueFromEntry: (entry: S, index: number) => S): Vector<S>;
    abstract matrixBuilder(): MatrixBuilder<S, Vector<S>, Matrix<S>>;
    abstract ops(): ScalarOperations<S>;
    outerProduct(other: Vector<S>): Matrix<S>;
    projectOnto(u: Vector<S>): Vector<S>;
    scalarMultiply(scalar: S): Vector<S>;
    set(index: number, value: S): Vector<S>;
    toArray(): S[];
}

// @public
export function backwardDifferenceMatrix(binCount: number): NumberMatrix;

// @public
export function calculateCholeskyDecomposition<S>(A: Matrix<S>): CholeskyDecomposition<S> | undefined;

// @public
export function calculateEigenvalues<S>(A: Matrix<S>, numIterations?: number): Vector<S>;

// @public
export function calculateGeneralLeastSquares<S>(dataPoints: Vector<S>[], functionTemplate: ApproximationFunctionTemplate<S>, numberOfTerms: number): LeastSquaresApproximation<S>;

// @public
export function calculateLinearLeastSquares<S>(dataPoints: Vector<S>[]): LeastSquaresApproximation<S>;

// @public
export function calculateLUDecomposition<S>(A: Matrix<S>): LUDecomposition<S>;

// @public
export function calculateQRDecomposition<S>(A: Matrix<S>): QRDecomposition<S>;

// @public
export function calculateSingularValueDecomposition<S>(A: Matrix<S>): SingularValueDecomposition<S>;

// @public
export function center<S>(x: Vector<S>): Vector<S>;

// @public
export function center<S>(A: Matrix<S>): Matrix<S>;

// @public
export function centralDifferenceMatrix(binCount: number): NumberMatrix;

// @public
export interface CholeskyDecomposition<S> {
    // (undocumented)
    L: Matrix<S>;
}

// @public
export interface Classifier<H> {
    getHyperParameters(): H;
    predict(data: Matrix, pThreshold: number): Vector;
    predictProbabilities(data: Matrix): Vector;
    train(data: Matrix, target: Vector): void;
}

// @public
export function columnSumSupremumNorm<S>(A: Matrix<S>): number;

// @public
export class ComplexMatrix extends ArrayMatrix<ComplexNumber> {
    // @internal
    constructor(data: MatrixData<ComplexNumber>);
    // (undocumented)
    static builder(): MatrixBuilder<ComplexNumber, ComplexVector, ComplexMatrix>;
    builder(): MatrixBuilder<ComplexNumber, ComplexVector, ComplexMatrix>;
    // (undocumented)
    static ops(): ScalarOperations<ComplexNumber>;
    ops(): ScalarOperations<ComplexNumber>;
    // (undocumented)
    static vectorBuilder(): VectorBuilder<ComplexNumber, ComplexVector>;
    vectorBuilder(): VectorBuilder<ComplexNumber, ComplexVector>;
}

// @public
export class ComplexNumber {
    constructor(real: number, imaginary: number);
    // (undocumented)
    add(other: ComplexNumber): ComplexNumber;
    // (undocumented)
    conjugate(): ComplexNumber;
    // (undocumented)
    equals(other: ComplexNumber): boolean;
    // (undocumented)
    getAdditiveInverse(): ComplexNumber;
    // (undocumented)
    getImaginaryPart(): number;
    // (undocumented)
    getMultiplicativeInverse(): ComplexNumber | undefined;
    // (undocumented)
    getRealPart(): number;
    // (undocumented)
    static readonly I: ComplexNumber;
    // (undocumented)
    multiply(other: ComplexNumber): ComplexNumber;
    // (undocumented)
    static readonly NEG_ONE: ComplexNumber;
    // (undocumented)
    static readonly ONE: ComplexNumber;
    // (undocumented)
    static readonly ZERO: ComplexNumber;
}

// @public
export class ComplexNumberOperations extends ScalarOperations<ComplexNumber> {
    add(first: ComplexNumber, second: ComplexNumber): ComplexNumber;
    conjugate(scalar: ComplexNumber): ComplexNumber;
    equals(first: ComplexNumber, second: ComplexNumber): boolean;
    fromComplex(real: number, imag: number): ComplexNumber;
    fromNumber(num: number): ComplexNumber;
    getAdditiveIdentity(): ComplexNumber;
    getAdditiveInverse(scalar: ComplexNumber): ComplexNumber;
    getMultiplicativeIdentity(): ComplexNumber;
    getMultiplicativeInverse(scalar: ComplexNumber): ComplexNumber | undefined;
    getPrincipalSquareRoot(x: ComplexNumber): ComplexNumber;
    multiply(first: ComplexNumber, second: ComplexNumber): ComplexNumber;
    norm(x: ComplexNumber): number;
    prettyPrint(x: ComplexNumber): string;
    random(min?: number, max?: number): ComplexNumber;
    randomNormal(mean?: number, standardDeviation?: number): ComplexNumber;
}

// @public
export class ComplexVector extends ArrayVector<ComplexNumber> {
    // @internal
    constructor(data: VectorData<ComplexNumber>);
    // (undocumented)
    static builder(): VectorBuilder<ComplexNumber, ComplexVector>;
    builder(): VectorBuilder<ComplexNumber, ComplexVector>;
    matrixBuilder(): MatrixBuilder<ComplexNumber, ComplexVector, ComplexMatrix>;
    // (undocumented)
    static ops(): ComplexNumberOperations;
    ops(): ComplexNumberOperations;
}

// @public
export function correlation<S>(first: Vector<S>, second: Vector<S>): S;

// @public
export function correlation<S>(A: Matrix<S>): Matrix<S>;

// @public
export interface Cost {
    // (undocumented)
    cost: number;
    // (undocumented)
    gradient: Vector;
}

// @public
export type CostFunction = (theta: Vector) => Cost;

// @public
export function covariance<S>(first: Vector<S>, second: Vector<S>): S;

// @public
export function covariance<S>(A: Matrix<S>): Matrix<S>;

// @public
export function crossProduct<S>(first: Vector<S>, second: Vector<S>): Vector<S>;

// @public
export function derivative(f: (x: number) => number, xMin: number, xMax: number, binCount: number): Vector;

// @public
export function determinant<S>(matrix: Matrix<S>): S;

// @public
export function diag(elements: number[]): Matrix;

// Warning: (ae-forgotten-export) The symbol "DimensionReductionType" needs to be exported by the entry point index.d.ts
//
// @public
export type DimensionReductionOptions = DimensionReductionType & {
    useCorrelation?: boolean;
};

// @public
export function dotProduct<S>(first: Vector<S>, second: Vector<S>): S;

// @public
export function eig<S>(A: Matrix<S>, numIterations?: number): EigenPair<S>[];

// @public
export interface EigenPair<S> {
    // (undocumented)
    eigenvalue: S;
    // (undocumented)
    eigenvector: Vector<S>;
}

// @public
export function euclideanNorm<S>(v: Vector<S>): number;

// @public
export function exp<S>(A: Matrix<S>, order?: number): Matrix<S>;

// @public
export function eye(size: number): Matrix;

// @public
export class FloatMatrix implements Matrix<number> {
    // @internal
    constructor(data: MatrixData<number>);
    constructor(data: Float64Array, shape: MatrixShape);
    add(other: Matrix<number>): Matrix<number>;
    adjoint(): Matrix<number>;
    apply(vector: Vector<number>): Vector<number>;
    // (undocumented)
    static builder(): MatrixBuilder<number, FloatVector, FloatMatrix>;
    builder(): MatrixBuilder<number, FloatVector, FloatMatrix>;
    combine(other: Matrix<number>, combineEntries: (a: number, b: number) => number): Matrix<number>;
    equals(other: Matrix<number>): boolean;
    forEach(cb: (entry: number, rowIndex: number, columnIndex: number) => void): void;
    getColumn(j: number): Vector<number>;
    getColumnVectors(): Vector<number>[];
    getDiagonal(): Vector<number>;
    getEntry(i: number, j: number): number;
    getNumberOfColumns(): number;
    getNumberOfRows(): number;
    getRow(i: number): Vector<number>;
    getRowVectors(): Vector<number>[];
    getShape(): MatrixShape;
    getSparseData(): Map<number, Map<number, number>>;
    map(entryFunction: (entry: number, rowIndex: number, columnIndex: number) => number): Matrix<number>;
    multiply(other: Matrix<number>): Matrix<number>;
    // (undocumented)
    static ops(): ScalarOperations<number>;
    ops(): ScalarOperations<number>;
    scalarMultiply(scalar: number): Matrix<number>;
    set(i: number, j: number, value: number): Matrix<number>;
    toArray(): number[][];
    trace(): number;
    transpose(): Matrix<number>;
    // (undocumented)
    static vectorBuilder(): VectorBuilder<number, FloatVector>;
    vectorBuilder(): VectorBuilder<number, FloatVector>;
}

// @public
export class FloatVector implements Vector<number> {
    // @internal
    constructor(data: VectorData<number> | Float64Array);
    add(other: Vector<number>): Vector<number>;
    // (undocumented)
    static builder(): VectorBuilder<number, FloatVector>;
    builder(): VectorBuilder<number, FloatVector>;
    combine(other: Vector<number>, combineEntries: (a: number, b: number) => number): Vector<number>;
    equals(other: Vector<number>): boolean;
    forEach(callback: (entry: number, index: number) => void): void;
    getDimension(): number;
    getEntry(index: number): number;
    getSparseData(): Map<number, number>;
    innerProduct(other: Vector<number>): number;
    map(valueFromEntry: (entry: number, index: number) => number): Vector<number>;
    matrixBuilder(): MatrixBuilder<number, FloatVector, FloatMatrix>;
    // (undocumented)
    static ops(): NumberOperations;
    ops(): NumberOperations;
    outerProduct(other: Vector<number>): Matrix<number>;
    projectOnto(u: Vector<number>): Vector<number>;
    scalarMultiply(scalar: number): Vector<number>;
    set(index: number, value: number): Vector<number>;
    toArray(): number[];
}

// @public
export function forwardDifferenceMatrix(binCount: number): NumberMatrix;

// @public
export function frobeniusNorm<S>(A: Matrix<S>): number;

// @public
export function GaussianKernel(sigmaSquared: number): Kernel;

// @public
export function getEigenvectorForEigenvalue<S>(A: Matrix<S>, lambda: S): Vector<S>;

// @public
export function gradientDescent(parameters: Partial<GradientDescentParameters>): LearningAlgorithm;

// @public
export type GradientDescentParameters = {
    alpha: number;
    maxIterations?: number;
};

// @public
export function hadamardProduct<S>(first: Vector<S>, second: Vector<S>): Vector<S>;

// @public
export function hadamardProduct<S>(first: Matrix<S>, second: Matrix<S>): Matrix<S>;

// @public
export function inverse<S>(matrix: Matrix<S>): Matrix<S> | undefined;

// @public
export function isHermitian<S>(matrix: Matrix<S>): boolean;

// @public
export function isIdentity<S>(matrix: Matrix<S>): boolean;

// @public
export function isLowerTriangular<S>(matrix: Matrix<S>): boolean;

// @public
export function isOrthogonal<S>(matrix: Matrix<S>): boolean;

// @public
export function isOrthonormal<S>(matrix: Matrix<S>): boolean;

// Warning: (ae-internal-missing-underscore) The name "isSparse" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export function isSparse<S>(vector: Vector<S>): vector is SparseVector<S>;

// @public
export function isSquare(matrix: Matrix<any>): boolean;

// @public
export function isSymmetric<S>(matrix: Matrix<S>): boolean;

// @public
export function isUpperTriangular<S>(matrix: Matrix<S>): boolean;

// @public
export type Kernel = (data: Matrix, trainingData?: Matrix) => Matrix;

// @public
export function kroneckerProduct<S>(first: Matrix<S>, second: Matrix<S>): Matrix<S>;

// @public
export type LearningAlgorithm = (initialTheta: Vector, costFn: CostFunction) => Vector;

// @public
export interface LeastSquaresApproximation<S> {
    approximationFunction: ApproximationFunction<S>;
    coefficients: Vector<S>;
}

// @public
export function LinearKernel(data: Matrix): Matrix;

// @public
export class LinearRegressor implements Regressor<LinearRegressorHyperparams> {
    constructor(hyperParameters: Partial<LinearRegressorHyperparams>);
    getHyperParameters(): LinearRegressorHyperparams;
    getParameters(): Vector | undefined;
    predict(data: Matrix): Vector;
    train(data: Matrix, target: Vector): void;
}

// @public
export type LinearRegressorHyperparams = GradientDescentParameters & {
    lambda: number;
};

// @public
export interface LinearTransformation<V, U> {
    apply(vector: V): U;
}

// @public
export function linspace(xMin: number, xMax: number, binCount: number): NumberVector;

// @public
export class LogisticRegressionClassifier implements Classifier<LogisticRegressionHyperparams> {
    constructor(hyperParameters: Partial<LogisticRegressionHyperparams>);
    getHyperParameters(): LogisticRegressionHyperparams;
    getParameters(): Vector | undefined;
    predict(data: Matrix): Vector;
    predictProbabilities(data: Matrix): Vector;
    train(data: Matrix, target: Vector): void;
}

// @public
export type LogisticRegressionHyperparams = GradientDescentParameters & {
    lambda: number;
};

// @public
export interface LUDecomposition<S> {
    // (undocumented)
    L: Matrix<S>;
    // (undocumented)
    P: Matrix<S>;
    // (undocumented)
    U: Matrix<S>;
}

// @public
export function mat(data: number[][]): Matrix;

// @public
export interface Matrix<S = number> extends LinearTransformation<Vector<S>, Vector<S>> {
    add(other: Matrix<S>): Matrix<S>;
    adjoint(): Matrix<S>;
    apply(vector: Vector<S>): Vector<S>;
    builder(): MatrixBuilder<S, Vector<S>, Matrix<S>>;
    combine(other: Matrix<S>, combineEntries: (a: S, b: S) => S): Matrix<S>;
    equals(other: Matrix<S>): boolean;
    forEach(callback: (entry: S, rowIndex: number, columnIndex: number) => void): void;
    getColumn(j: number): Vector<S>;
    getColumnVectors(): Vector<S>[];
    getDiagonal(): Vector<S>;
    getEntry(i: number, j: number): S;
    getNumberOfColumns(): number;
    getNumberOfRows(): number;
    getRow(i: number): Vector<S>;
    getRowVectors(): Vector<S>[];
    getShape(): MatrixShape;
    getSparseData(): Map<number, Map<number, S>>;
    map(entryFunction: (entry: S, rowIndex: number, columnIndex: number) => S): Matrix<S>;
    multiply(other: Matrix<S>): Matrix<S>;
    ops(): ScalarOperations<S>;
    scalarMultiply(scalar: S): Matrix<S>;
    set(i: number, j: number, value: S): Matrix<S>;
    toArray(): S[][];
    trace(): S;
    transpose(): Matrix<S>;
    vectorBuilder(): VectorBuilder<S, Vector<S>>;
}

// @public
export class MatrixBuilder<S, V extends Vector<S>, M extends Matrix<S>> {
    // @internal
    constructor(matrixConstructor: MatrixConstructor<S, V, M>);
    augment(left: Matrix<S>, right: Matrix<S>): M;
    block(grid: Matrix<S>[][]): M;
    blockDiagonal(matrices: Matrix<S>[]): M;
    circulant(vector: Vector<S>): M;
    diagonal(diagonalEntries: Vector<S>): M;
    empty(): M;
    exclude(matrix: Matrix<S>, rowToExclude: number, columnToExclude: number): M;
    fill(value: S, shape: MatrixShape): M;
    // (undocumented)
    fromArray(data: MatrixData<S>): M;
    fromColumnVectors(columns: Vector<S>[]): M;
    fromIndexFunction(shape: MatrixShape, indexFunction: (i: number, j: number) => S): M;
    // (undocumented)
    fromNumberArray(numberData: MatrixData<number>): M;
    fromRowVectors(rows: Vector<S>[]): M;
    // (undocumented)
    fromSparseData(shape: MatrixShape, sparseData: SparseMatrixData<S>): M;
    hankel(firstColumn: Vector<S>, lastRow?: Vector<S>): M;
    hilbert(size: number): M;
    identity(size: number): M;
    ones(shape: MatrixShape): M;
    pascal(size: number, upper?: boolean): M;
    pascalSymmetric(size: number): M;
    random(shape: MatrixShape, min?: number, max?: number): M;
    randomNormal(shape: MatrixShape, mean?: number, standardDeviation?: number): M;
    repeat(matrix: Matrix<S>, rows: number, columns: number): M;
    slice(matrix: Matrix<S>, rowStartIndex?: number, columnStartIndex?: number, rowEndIndex?: number, columnEndIndex?: number): M;
    toeplitz(firstColumn: Vector<S>, firstRow?: Vector<S>): M;
    tridiagonal(leftEntries: Vector<S>, diagonalEntries: Vector<S>, rightEntries: Vector<S>): M;
    zeros(shape: MatrixShape): M;
}

// Warning: (ae-internal-missing-underscore) The name "MatrixConstructor" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface MatrixConstructor<S, V extends Vector<S>, M extends Matrix<S>> {
    // (undocumented)
    new (data: MatrixData<S>): M;
    // (undocumented)
    builder(): MatrixBuilder<S, V, M>;
    // (undocumented)
    ops(): ScalarOperations<S>;
    // (undocumented)
    vectorBuilder(): VectorBuilder<S, V>;
}

// @public
export type MatrixData<S> = readonly VectorData<S>[];

// @public
export type MatrixEntryFunction<S> = (entry: S, i: number, j: number) => S;

// @public
export type MatrixShape = [number, number];

// @public
export function mean<S>(x: Vector<S>): S;

// @public
export function mean<S>(A: Matrix<S>): Vector<S>;

// @public
export type Norm<S = number> = (v: Vector<S>) => number;

// @public
export function normalize<S>(v: Vector<S>): Vector<S> | undefined;

// @public
export class NumberMatrix extends ArrayMatrix<number> {
    // @internal
    constructor(data: MatrixData<number>);
    // (undocumented)
    static builder(): MatrixBuilder<number, NumberVector, NumberMatrix>;
    builder(): MatrixBuilder<number, NumberVector, NumberMatrix>;
    // (undocumented)
    static ops(): ScalarOperations<number>;
    ops(): ScalarOperations<number>;
    // (undocumented)
    static vectorBuilder(): VectorBuilder<number, NumberVector>;
    vectorBuilder(): VectorBuilder<number, NumberVector>;
}

// @public
export class NumberOperations extends ScalarOperations<number> {
    add(first: number, second: number): number;
    conjugate(scalar: number): number;
    equals(first: number, second: number): boolean;
    fromNumber(num: number): number;
    getAdditiveIdentity(): number;
    getAdditiveInverse(x: number): number;
    getMultiplicativeIdentity(): number;
    getMultiplicativeInverse(x: number): number | undefined;
    getPrincipalSquareRoot(x: number): number | undefined;
    multiply(first: number, second: number): number;
    norm(x: number): number;
    prettyPrint(x: number): string;
    random(min?: number, max?: number): number;
    randomNormal(mean?: number, standardDeviation?: number): number;
}

// @public
export class NumberVector extends ArrayVector<number> {
    // @internal
    constructor(data: VectorData<number>);
    // (undocumented)
    static builder(): VectorBuilder<number, NumberVector>;
    builder(): VectorBuilder<number, NumberVector>;
    matrixBuilder(): MatrixBuilder<number, NumberVector, NumberMatrix>;
    // (undocumented)
    static ops(): NumberOperations;
    ops(): NumberOperations;
}

// @public
export function ones(entries: number): Vector;

// @public
export function ones(shape: MatrixShape): Matrix;

// @public
export function pca<S>(A: Matrix<S>, useCorrelation?: boolean): PrincipalComponentAnalysis<S>;

// @public
export function pNorm<S>(v: Vector<S>, p: number): number;

// @public
export function pow<S>(A: Matrix<S>, n: number): Matrix<S>;

// @public
export function prettyPrint(num: number): string;

// @public
export function prettyPrint<S>(vector: Vector<S>): string;

// @public
export function prettyPrint<S>(matrix: Matrix<S>): string;

// @public
export interface PrincipalComponentAnalysis<S> {
    coordinates: Matrix<S>;
    cumulativeProportions: S[];
    principalComponents: Vector<S>[];
    proportions: S[];
    variances: S[];
}

// @public
export interface QRDecomposition<S> {
    // (undocumented)
    Q: Matrix<S>;
    // (undocumented)
    R: Matrix<S>;
}

// @public
export function RadialBasisFunction(distanceMetric: SimilarityMetric): Kernel;

// @public
export function rank<S>(matrix: Matrix<S>): number;

// @public
export function reduceDimensions(A: Matrix, options: DimensionReductionOptions): Matrix;

// @public
export function reducedRowEchelonForm<S>(matrix: Matrix<S>): Matrix<S>;

// @public
export interface Regressor<H> {
    getHyperParameters(): H;
    predict(data: Matrix): Vector;
    train(data: Matrix, target: Vector): void;
}

// @public
export function rowEchelonForm<S>(matrix: Matrix<S>): Matrix<S>;

// @public
export interface RowOperationResult<S> {
    // (undocumented)
    operator: Matrix<S>;
    // (undocumented)
    result: Matrix<S>;
}

// @public
export class RowOperations {
    static addRowToRow<S>(matrix: Matrix<S>, targetRow: number, rowToAdd: number): Matrix<S>;
    static addScalarMultipleOfRowToRow<S>(matrix: Matrix<S>, targetRow: number, rowToAdd: number, scalar: S): Matrix<S>;
    static exchangeRows<S>(matrix: Matrix<S>, first: number, second: number): Matrix<S>;
    static multiplyRowByScalar<S>(matrix: Matrix<S>, rowIndex: number, scalar: S): Matrix<S>;
    static pivot<S>(matrix: Matrix<S>): RowOperationResult<S>;
}

// @public
export function rowSumSupremumNorm<S>(A: Matrix<S>): number;

// @public
export abstract class ScalarOperations<S> {
    abstract add(first: S, second: S): S;
    abstract conjugate(scalar: S): S;
    divide(numerator: S, denominator: S): S | undefined;
    abstract equals(first: S, second: S): boolean;
    fromComplex(real: number, imaginary: number): S;
    abstract fromNumber(num: number): S;
    abstract getAdditiveIdentity(): S;
    abstract getAdditiveInverse(x: S): S;
    abstract getMultiplicativeIdentity(): S;
    abstract getMultiplicativeInverse(x: S): S | undefined;
    abstract getPrincipalSquareRoot(x: S): S | undefined;
    abstract multiply(first: S, second: S): S;
    negativeOne(): S;
    abstract norm(x: S): number;
    one(): S;
    abstract prettyPrint(x: S): string;
    abstract random(min: number, max: number): S;
    abstract randomNormal(mean: number, standardDeviation: number): S;
    subtract(first: S, second: S): S;
    zero(): S;
}

// @public
export type SimilarityMetric = (v1: Vector, v2: Vector) => number;

// @public
export interface SingularValueDecomposition<S> {
    // (undocumented)
    Sigma: Matrix<S>;
    // (undocumented)
    U: Matrix<S>;
    // (undocumented)
    V: Matrix<S>;
}

// Warning: (ae-forgotten-export) The symbol "LinearSolution" needs to be exported by the entry point index.d.ts
//
// @public
export function solveByGaussianElimination<S>(A: Matrix<S>, b: Vector<S>): LinearSolution<S>;

// @public
export function solveOverdeterminedSystem<S>(A: Matrix<S>, b: Vector<S>): Vector<S>;

// @public
export abstract class SparseMatrix<S = number> implements Matrix<S> {
    // @internal
    protected constructor(data: MatrixData<S>);
    add(other: Matrix<S>): Matrix<S>;
    adjoint(): Matrix<S>;
    apply(vector: Vector<S>): Vector<S>;
    abstract builder(): MatrixBuilder<S, Vector<S>, Matrix<S>>;
    combine(other: Matrix<S>, combineEntries: (a: S, b: S) => S): Matrix<S>;
    equals(other: Matrix<S>): boolean;
    forEach(cb: (entry: S, rowIndex: number, columnIndex: number) => void): void;
    getColumn(j: number): Vector<S>;
    getColumnVectors(): Vector<S>[];
    getDiagonal(): Vector<S>;
    getEntry(i: number, j: number): S;
    getNumberOfColumns(): number;
    getNumberOfRows(): number;
    getRow(i: number): Vector<S>;
    getRowVectors(): Vector<S>[];
    getShape(): MatrixShape;
    getSparseData(): Map<number, Map<number, S>>;
    map(entryFunction: (entry: S, rowIndex: number, columnIndex: number) => S): Matrix<S>;
    multiply(other: Matrix<S>): Matrix<S>;
    abstract ops(): ScalarOperations<S>;
    scalarMultiply(scalar: S): Matrix<S>;
    set(i: number, j: number, value: S): Matrix<S>;
    toArray(): S[][];
    trace(): S;
    transpose(): Matrix<S>;
    abstract vectorBuilder(): VectorBuilder<S, Vector<S>>;
}

// @public
export type SparseMatrixData<S> = ReadonlyMap<number, ReadonlyMap<number, S>>;

// @public
export class SparseNumberMatrix extends SparseMatrix<number> {
    // @internal
    constructor(data: MatrixData<number>);
    // (undocumented)
    static builder(): MatrixBuilder<number, SparseNumberVector, SparseNumberMatrix>;
    builder(): MatrixBuilder<number, SparseNumberVector, SparseNumberMatrix>;
    // (undocumented)
    static ops(): ScalarOperations<number>;
    ops(): ScalarOperations<number>;
    // (undocumented)
    static vectorBuilder(): VectorBuilder<number, SparseNumberVector>;
    vectorBuilder(): VectorBuilder<number, SparseNumberVector>;
}

// @public
export class SparseNumberVector extends SparseVector<number> {
    // @internal
    constructor(data: VectorData<number>);
    // (undocumented)
    static builder(): VectorBuilder<number, SparseNumberVector>;
    // (undocumented)
    builder(): VectorBuilder<number, SparseNumberVector>;
    // (undocumented)
    matrixBuilder(): MatrixBuilder<number, SparseNumberVector, SparseNumberMatrix>;
    // (undocumented)
    static ops(): ScalarOperations<number>;
    // (undocumented)
    ops(): ScalarOperations<number>;
}

// @public
export abstract class SparseVector<S = number> implements Vector<S> {
    // @internal
    protected constructor(data: VectorData<S>);
    add(other: Vector<S>): Vector<S>;
    // (undocumented)
    abstract builder(): VectorBuilder<S, Vector<S>>;
    combine(other: Vector<S>, combineEntries: (a: S, b: S) => S): Vector<S>;
    equals(other: Vector<S>): boolean;
    forEach(callback: (entry: S, index: number) => void): void;
    getDimension(): number;
    getEntry(index: number): S;
    getSparseData(): Map<number, S>;
    innerProduct(other: Vector<S>): S;
    map(valueFromEntry: (entry: S, index: number) => S): Vector<S>;
    // (undocumented)
    abstract matrixBuilder(): MatrixBuilder<S, Vector<S>, Matrix<S>>;
    // (undocumented)
    abstract ops(): ScalarOperations<S>;
    outerProduct(other: Vector<S>): Matrix<S>;
    projectOnto(u: Vector<S>): Vector<S>;
    scalarMultiply(scalar: S): Vector<S>;
    set(index: number, value: S): Vector<S>;
    toArray(): S[];
}

// @public
export type SparseVectorData<S> = ReadonlyMap<number, S>;

// @public
export function standardDeviation<S>(x: Vector<S>): S;

// @public
export function standardDeviation<S>(A: Matrix<S>): Vector<S>;

// @public
export function standardize<S>(x: Vector<S>): Vector<S>;

// @public
export function standardize<S>(A: Matrix<S>): Matrix<S>;

// @public
export function sumNorm<S>(v: Vector<S>): number;

// @public
export class SupportVectorMachineClassifier implements Classifier<SupportVectorMachineHyperparams> {
    constructor(hyperParameters: Partial<SupportVectorMachineHyperparams>);
    getHyperParameters(): SupportVectorMachineHyperparams;
    getParameters(): Vector | undefined;
    predict(data: Matrix): Vector;
    predictProbabilities(_data: Matrix): Vector;
    train(data: Matrix, target: Vector): void;
    }

// @public
export type SupportVectorMachineHyperparams = GradientDescentParameters & {
    C: number;
    kernel: Kernel;
};

// @public
export function supremumNorm<S>(v: Vector<S>): number;

// @public
export function tripleProduct<S>(first: Vector<S>, second: Vector<S>, third: Vector<S>): S;

// @public
export function variance<S>(x: Vector<S>): S;

// @public
export function variance<S>(A: Matrix<S>): Vector<S>;

// @public
export function vec(data: number[]): Vector;

// @public
export interface Vector<S = number> {
    add(other: Vector<S>): Vector<S>;
    builder(): VectorBuilder<S, Vector<S>>;
    combine(other: Vector<S>, combineEntries: (a: S, b: S) => S): Vector<S>;
    equals(other: Vector<S>): boolean;
    forEach(callback: (entry: S, index: number) => void): void;
    getDimension(): number;
    getEntry(index: number): S;
    getSparseData(): Map<number, S>;
    innerProduct(other: Vector<S>): S;
    map(valueFromEntry: (entry: S, index: number) => S): Vector<S>;
    matrixBuilder(): MatrixBuilder<S, Vector<S>, Matrix<S>>;
    ops(): ScalarOperations<S>;
    outerProduct(other: Vector<S>): Matrix<S>;
    projectOnto(u: Vector<S>): Vector<S>;
    scalarMultiply(scalar: S): Vector<S>;
    set(index: number, value: S): Vector<S>;
    toArray(): S[];
}

// @public
export class VectorBuilder<S, V extends Vector<S>> {
    // @internal
    constructor(vectorConstructor: VectorConstructor<S, V>);
    concatenate(first: Vector<S>, second: Vector<S>): V;
    elementaryVector(dimension: number, oneIndex: number): V;
    empty(): V;
    fill(value: S, dimension: number): V;
    // (undocumented)
    fromArray(data: VectorData<S>): V;
    fromIndexFunction(dimension: number, valueFromIndex: VectorIndexFunction<S>): V;
    // (undocumented)
    fromNumberArray(data: VectorData<number>): V;
    // (undocumented)
    fromSparseData(dimension: number, sparseData: SparseVectorData<S>): V;
    // (undocumented)
    fromValues(...data: VectorData<S>): V;
    ones(dimension: number): V;
    random(dimension: number, min?: number, max?: number): V;
    randomNormal(dimension: number, mean?: number, standardDeviation?: number): V;
    shift(vector: Vector<S>, offset?: number, reverse?: boolean): V;
    zeros(dimension: number): V;
}

// Warning: (ae-internal-missing-underscore) The name "VectorConstructor" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface VectorConstructor<S, V extends Vector<S>> {
    // (undocumented)
    new (data: VectorData<S>): V;
    // (undocumented)
    builder(): VectorBuilder<S, V>;
    // (undocumented)
    ops(): ScalarOperations<S>;
}

// @public
export type VectorData<S> = readonly S[];

// @public
export type VectorIndexFunction<S> = (index: number) => S;

// @public
export function zeros(entries: number): Vector;

// @public
export function zeros(shape: MatrixShape): Matrix;


// (No @packageDocumentation comment for this package)

```
