## API Report File for "@josh-brown/vector"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export function addRowToRow<S>(matrix: Matrix<S>, targetRow: number, rowToAdd: number): Matrix<S>;

// @public
export function addScalarMultipleOfRowToRow<S>(matrix: Matrix<S>, targetRow: number, rowToAdd: number, scalar: S): Matrix<S>;

// @public
export type ApproximationFunction<S> = (input: Vector<S>) => S;

// @public
export type ApproximationFunctionTemplate<S> = (coefficients: Vector<S>) => ApproximationFunction<S>;

// @public
export abstract class ArrayMatrix<S> implements Matrix<S> {
    // @internal
    protected constructor(data: MatrixData<S>);
    add(other: Matrix<S>): Matrix<S>;
    adjoint(): Matrix<S>;
    apply(vector: Vector<S>): Vector<S>;
    abstract builder(): MatrixBuilder<S, Vector<S>, Matrix<S>>;
    equals(other: Matrix<S>): boolean;
    forEachEntry(cb: MatrixEntryCallback<S>): void;
    getColumn(j: number): Vector<S>;
    getColumnVectors(): Vector<S>[];
    getDiagonal(): Vector<S>;
    getEntry(i: number, j: number): S;
    getNumberOfColumns(): number;
    getNumberOfRows(): number;
    getRow(i: number): Vector<S>;
    getRowVectors(): Vector<S>[];
    getSparseData(): Map<number, Map<number, S>>;
    multiply(other: Matrix<S>): Matrix<S>;
    abstract ops(): ScalarOperations<S>;
    scalarMultiply(scalar: S): Matrix<S>;
    set(i: number, j: number, value: S): Matrix<S>;
    toArray(): S[][];
    trace(): S;
    transpose(): Matrix<S>;
    abstract vectorBuilder(): VectorBuilder<S, Vector<S>>;
}

// @public
export abstract class ArrayVector<S> implements Vector<S> {
    // @internal
    protected constructor(data: VectorData<S>);
    add(other: Vector<S>): Vector<S>;
    abstract builder(): VectorBuilder<S, Vector<S>>;
    equals(other: Vector<S>): boolean;
    getDimension(): number;
    getEntry(index: number): S;
    getSparseData(): Map<number, S>;
    innerProduct(other: Vector<S>): S;
    abstract matrixBuilder(): MatrixBuilder<S, Vector<S>, Matrix<S>>;
    abstract ops(): ScalarOperations<S>;
    outerProduct(other: Vector<S>): Matrix<S>;
    projectOnto(u: Vector<S>): Vector<S>;
    scalarMultiply(scalar: S): Vector<S>;
    toArray(): S[];
}

// @public
export function backwardDifferenceMatrix(binCount: number): NumberMatrix;

// @public
export function calculateCholeskyDecomposition<S>(A: Matrix<S>): CholeskyDecomposition<S> | undefined;

// @public
export function calculateEigenvalues<S>(A: Matrix<S>, numIterations?: number): Vector<S>;

// @public
export function calculateGeneralLeastSquares<S>(dataPoints: Vector<S>[], functionTemplate: ApproximationFunctionTemplate<S>, numberOfTerms: number): LeastSquaresApproximation<S>;

// @public
export function calculateLinearLeastSquares<S>(dataPoints: Vector<S>[]): LeastSquaresApproximation<S>;

// @public
export function calculateLUDecomposition<S>(A: Matrix<S>): LUDecomposition<S>;

// @public
export function calculateQRDecomposition<S>(A: Matrix<S>): QRDecomposition<S>;

// @public
export function calculateSingularValueDecomposition<S>(A: Matrix<S>): SingularValueDecomposition<S>;

// @public
export function centralDifferenceMatrix(binCount: number): NumberMatrix;

// @public
export interface CholeskyDecomposition<S> {
    // (undocumented)
    L: Matrix<S>;
}

// @public
export function columnSumSupremumNorm<S>(A: Matrix<S>): number;

// @public
export class ComplexMatrix extends ArrayMatrix<ComplexNumber> {
    // @internal
    constructor(data: MatrixData<ComplexNumber>);
    // (undocumented)
    static builder(): MatrixBuilder<ComplexNumber, ComplexVector, ComplexMatrix>;
    builder(): MatrixBuilder<ComplexNumber, ComplexVector, ComplexMatrix>;
    // (undocumented)
    static ops(): ScalarOperations<ComplexNumber>;
    ops(): ScalarOperations<ComplexNumber>;
    // (undocumented)
    static vectorBuilder(): VectorBuilder<ComplexNumber, ComplexVector>;
    vectorBuilder(): VectorBuilder<ComplexNumber, ComplexVector>;
}

// @public
export class ComplexNumber {
    constructor(real: number, imaginary: number);
    // (undocumented)
    add(other: ComplexNumber): ComplexNumber;
    // (undocumented)
    conjugate(): ComplexNumber;
    // (undocumented)
    equals(other: ComplexNumber): boolean;
    // (undocumented)
    getAdditiveInverse(): ComplexNumber;
    // (undocumented)
    getImaginaryPart(): number;
    // (undocumented)
    getMultiplicativeInverse(): ComplexNumber | undefined;
    // (undocumented)
    getRealPart(): number;
    // (undocumented)
    static readonly I: ComplexNumber;
    // (undocumented)
    multiply(other: ComplexNumber): ComplexNumber;
    // (undocumented)
    static readonly NEG_ONE: ComplexNumber;
    // (undocumented)
    static readonly ONE: ComplexNumber;
    // (undocumented)
    static readonly ZERO: ComplexNumber;
}

// @public
export class ComplexNumberOperations extends ScalarOperations<ComplexNumber> {
    add(first: ComplexNumber, second: ComplexNumber): ComplexNumber;
    conjugate(scalar: ComplexNumber): ComplexNumber;
    equals(first: ComplexNumber, second: ComplexNumber): boolean;
    fromComplex(real: number, imag: number): ComplexNumber;
    fromNumber(num: number): ComplexNumber;
    getAdditiveIdentity(): ComplexNumber;
    getAdditiveInverse(scalar: ComplexNumber): ComplexNumber;
    getMultiplicativeIdentity(): ComplexNumber;
    getMultiplicativeInverse(scalar: ComplexNumber): ComplexNumber | undefined;
    getPrincipalSquareRoot(x: ComplexNumber): ComplexNumber;
    multiply(first: ComplexNumber, second: ComplexNumber): ComplexNumber;
    norm(x: ComplexNumber): number;
    prettyPrint(x: ComplexNumber): string;
    random(min?: number, max?: number): ComplexNumber;
    randomNormal(mean?: number, standardDeviation?: number): ComplexNumber;
}

// @public
export class ComplexVector extends ArrayVector<ComplexNumber> {
    // @internal
    constructor(data: VectorData<ComplexNumber>);
    // (undocumented)
    static builder(): VectorBuilder<ComplexNumber, ComplexVector>;
    builder(): VectorBuilder<ComplexNumber, ComplexVector>;
    matrixBuilder(): MatrixBuilder<ComplexNumber, ComplexVector, ComplexMatrix>;
    // (undocumented)
    static ops(): ComplexNumberOperations;
    ops(): ComplexNumberOperations;
}

// @public
export function crossProduct<S>(first: Vector<S>, second: Vector<S>): Vector<S>;

// @public
export function derivative(f: (x: number) => number, xMin: number, xMax: number, binCount: number): Vector<number>;

// @public
export function determinant<S>(matrix: Matrix<S>): S;

// @public
export function eig<S>(A: Matrix<S>, numIterations?: number): EigenPair<S>[];

// @public
export interface EigenPair<S> {
    // (undocumented)
    eigenvalue: S;
    // (undocumented)
    eigenvector: Vector<S>;
}

// @public
export function euclideanNorm<S>(v: Vector<S>): number;

// @public
export function exchangeRows<S>(matrix: Matrix<S>, first: number, second: number): Matrix<S>;

// @public
export function exp<S>(A: Matrix<S>, order?: number): Matrix<S>;

// @public
export function forwardDifferenceMatrix(binCount: number): NumberMatrix;

// @public
export function frobeniusNorm<S>(A: Matrix<S>): number;

// @public
export function getEigenvectorForEigenvalue<S>(A: Matrix<S>, lambda: S): Vector<S>;

// @public
export function inverse<S>(matrix: Matrix<S>): Matrix<S> | undefined;

// @public
export function isHermitian<S>(matrix: Matrix<S>): boolean;

// @public
export function isIdentity<S>(matrix: Matrix<S>): boolean;

// @public
export function isLowerTriangular<S>(matrix: Matrix<S>): boolean;

// @public
export function isOrthogonal<S>(matrix: Matrix<S>): boolean;

// @public
export function isOrthonormal<S>(matrix: Matrix<S>): boolean;

// Warning: (ae-internal-missing-underscore) The name "isSparse" should be prefixed with an underscore because the declaration is marked as @internal
// 
// @internal
export function isSparse<S>(vector: Vector<S>): vector is SparseVector<S>;

// @public
export function isSquare(matrix: Matrix<any>): boolean;

// @public
export function isSymmetric<S>(matrix: Matrix<S>): boolean;

// @public
export function isUpperTriangular<S>(matrix: Matrix<S>): boolean;

// @public
export interface LeastSquaresApproximation<S> {
    approximationFunction: ApproximationFunction<S>;
    coefficients: Vector<S>;
}

// @public
export interface LinearTransformation<V, U> {
    apply(vector: V): U;
}

// @public
export function linspace(xMin: number, xMax: number, binCount: number): NumberVector;

// @public
export interface LUDecomposition<S> {
    // (undocumented)
    L: Matrix<S>;
    // (undocumented)
    P: Matrix<S>;
    // (undocumented)
    U: Matrix<S>;
}

// @public
export interface Matrix<S> extends LinearTransformation<Vector<S>, Vector<S>> {
    add(other: Matrix<S>): Matrix<S>;
    adjoint(): Matrix<S>;
    apply(vector: Vector<S>): Vector<S>;
    builder(): MatrixBuilder<S, Vector<S>, Matrix<S>>;
    equals(other: Matrix<S>): boolean;
    forEachEntry(callback: MatrixEntryCallback<S>): void;
    getColumn(j: number): Vector<S>;
    getColumnVectors(): Vector<S>[];
    getDiagonal(): Vector<S>;
    getEntry(i: number, j: number): S;
    getNumberOfColumns(): number;
    getNumberOfRows(): number;
    getRow(i: number): Vector<S>;
    getRowVectors(): Vector<S>[];
    getSparseData(): Map<number, Map<number, S>>;
    multiply(other: Matrix<S>): Matrix<S>;
    ops(): ScalarOperations<S>;
    scalarMultiply(scalar: S): Matrix<S>;
    set(i: number, j: number, value: S): Matrix<S>;
    toArray(): S[][];
    trace(): S;
    transpose(): Matrix<S>;
    vectorBuilder(): VectorBuilder<S, Vector<S>>;
}

// @public
export class MatrixBuilder<S, V extends Vector<S>, M extends Matrix<S>> {
    // @internal
    constructor(matrixConstructor: MatrixConstructor<S, V, M>);
    augment(left: Matrix<S>, right: Matrix<S>): M;
    block(grid: Matrix<S>[][]): M;
    blockDiagonal(matrices: Matrix<S>[]): M;
    circulant(vector: Vector<S>): M;
    diagonal(diagonalEntries: V): M;
    empty(): M;
    exclude(matrix: M, rowToExclude: number, columnToExclude: number): M;
    fill(value: S, numberOfRows: number, numberOfColumns?: number): M;
    // (undocumented)
    fromArray(data: MatrixData<S>): M;
    fromColumnVectors(columns: Vector<S>[]): M;
    fromIndexFunction(numRows: number, numColumns: number, indexFunction: MatrixIndexFunction<S>): M;
    // (undocumented)
    fromNumberArray(numberData: MatrixData<number>): M;
    fromRowVectors(rows: Vector<S>[]): M;
    // (undocumented)
    fromSparseData(numRows: number, numCols: number, sparseData: SparseMatrixData<S>): M;
    hankel(firstColumn: Vector<S>, lastRow?: Vector<S>): M;
    hilbert(size: number): M;
    identity(size: number): M;
    map(matrix: Matrix<S>, entryFunction: MatrixEntryFunction<S>): M;
    ones(numberOfRows: number, numberOfColumns?: number): M;
    pascal(size: number, upper?: boolean): M;
    pascalSymmetric(size: number): M;
    random(numberOfRows: number, numberOfColumns?: number, min?: number, max?: number): M;
    randomNormal(numberOfRows: number, numberOfColumns?: number, mean?: number, standardDeviation?: number): M;
    repeat(matrix: M, rows: number, columns: number): M;
    slice(matrix: Matrix<S>, rowStartIndex?: number, columnStartIndex?: number, rowEndIndex?: number, columnEndIndex?: number): M;
    toeplitz(firstColumn: Vector<S>, firstRow?: Vector<S>): M;
    tridiagonal(leftEntries: Vector<S>, diagonalEntries: Vector<S>, rightEntries: Vector<S>): M;
    zeros(numberOfRows: number, numberOfColumns?: number): M;
}

// Warning: (ae-internal-missing-underscore) The name "MatrixConstructor" should be prefixed with an underscore because the declaration is marked as @internal
// 
// @internal (undocumented)
export interface MatrixConstructor<S, V extends Vector<S>, M extends Matrix<S>> {
    // (undocumented)
    new (data: MatrixData<S>): M;
    // (undocumented)
    builder(): MatrixBuilder<S, V, M>;
    // (undocumented)
    ops(): ScalarOperations<S>;
    // (undocumented)
    vectorBuilder(): VectorBuilder<S, V>;
}

// @public
export type MatrixData<S> = readonly VectorData<S>[];

// @public
export type MatrixEntryCallback<S> = (entry: S, rowIndex: number, columnIndex: number) => void;

// @public
export type MatrixEntryFunction<S> = (entry: S, i: number, j: number) => S;

// @public
export type MatrixIndexFunction<S> = (i: number, j: number) => S;

// @public
export function multiplyRowByScalar<S>(matrix: Matrix<S>, rowIndex: number, scalar: S): Matrix<S>;

// @public
export function normalize<S>(v: Vector<S>): Vector<S> | undefined;

// @public
export class NumberMatrix extends ArrayMatrix<number> {
    // @internal
    constructor(data: MatrixData<number>);
    // (undocumented)
    static builder(): MatrixBuilder<number, NumberVector, NumberMatrix>;
    builder(): MatrixBuilder<number, NumberVector, NumberMatrix>;
    // (undocumented)
    static ops(): ScalarOperations<number>;
    ops(): ScalarOperations<number>;
    // (undocumented)
    static vectorBuilder(): VectorBuilder<number, NumberVector>;
    vectorBuilder(): VectorBuilder<number, NumberVector>;
}

// @public
export class NumberOperations extends ScalarOperations<number> {
    add(first: number, second: number): number;
    conjugate(scalar: number): number;
    equals(first: number, second: number): boolean;
    fromNumber(num: number): number;
    getAdditiveIdentity(): number;
    getAdditiveInverse(x: number): number;
    getMultiplicativeIdentity(): number;
    getMultiplicativeInverse(x: number): number | undefined;
    getPrincipalSquareRoot(x: number): number | undefined;
    multiply(first: number, second: number): number;
    norm(x: number): number;
    prettyPrint(x: number): string;
    random(min?: number, max?: number): number;
    randomNormal(mean?: number, standardDeviation?: number): number;
}

// @public
export class NumberVector extends ArrayVector<number> {
    // @internal
    constructor(data: VectorData<number>);
    // (undocumented)
    static builder(): VectorBuilder<number, NumberVector>;
    builder(): VectorBuilder<number, NumberVector>;
    matrixBuilder(): MatrixBuilder<number, NumberVector, NumberMatrix>;
    // (undocumented)
    static ops(): NumberOperations;
    ops(): NumberOperations;
}

// @public
export function pivot<S>(matrix: Matrix<S>): RowOperationResult<S>;

// @public
export function pNorm<S>(v: Vector<S>, p: number): number;

// @public
export function pow<S>(A: Matrix<S>, n: number): Matrix<S>;

// @public
export function prettyPrint(num: number): string;

// @public
export function prettyPrint<S>(vector: Vector<S>): string;

// @public
export function prettyPrint<S>(matrix: Matrix<S>): string;

// @public
export interface QRDecomposition<S> {
    // (undocumented)
    Q: Matrix<S>;
    // (undocumented)
    R: Matrix<S>;
}

// @public
export function rank<S>(matrix: Matrix<S>): number;

// @public
export function reducedRowEchelonForm<S>(matrix: Matrix<S>): Matrix<S>;

// @public
export function rowEchelonForm<S>(matrix: Matrix<S>): Matrix<S>;

// @public
export interface RowOperationResult<S> {
    // (undocumented)
    operator: Matrix<S>;
    // (undocumented)
    result: Matrix<S>;
}

// @public
export function rowSumSupremumNorm<S>(A: Matrix<S>): number;

// @public
export abstract class ScalarOperations<S> {
    abstract add(first: S, second: S): S;
    abstract conjugate(scalar: S): S;
    divide(numerator: S, denominator: S): S | undefined;
    abstract equals(first: S, second: S): boolean;
    fromComplex(real: number, imaginary: number): S;
    abstract fromNumber(num: number): S;
    abstract getAdditiveIdentity(): S;
    abstract getAdditiveInverse(x: S): S;
    abstract getMultiplicativeIdentity(): S;
    abstract getMultiplicativeInverse(x: S): S | undefined;
    abstract getPrincipalSquareRoot(x: S): S | undefined;
    abstract multiply(first: S, second: S): S;
    negativeOne(): S;
    abstract norm(x: S): number;
    one(): S;
    abstract prettyPrint(x: S): string;
    abstract random(min: number, max: number): S;
    abstract randomNormal(mean: number, standardDeviation: number): S;
    subtract(first: S, second: S): S;
    zero(): S;
}

// @public
export interface SingularValueDecomposition<S> {
    // (undocumented)
    Sigma: Matrix<S>;
    // (undocumented)
    U: Matrix<S>;
    // (undocumented)
    V: Matrix<S>;
}

// Warning: (ae-forgotten-export) The symbol "LinearSolution" needs to be exported by the entry point index.d.ts
// 
// @public
export function solveByGaussianElimination<S>(A: Matrix<S>, b: Vector<S>): LinearSolution<S>;

// @public
export function solveOverdeterminedSystem<S>(A: Matrix<S>, b: Vector<S>): Vector<S>;

// @public
export abstract class SparseMatrix<S> implements Matrix<S> {
    // @internal
    protected constructor(data: MatrixData<S>);
    add(other: Matrix<S>): Matrix<S>;
    adjoint(): Matrix<S>;
    apply(vector: Vector<S>): Vector<S>;
    abstract builder(): MatrixBuilder<S, Vector<S>, Matrix<S>>;
    equals(other: Matrix<S>): boolean;
    forEachEntry(cb: MatrixEntryCallback<S>): void;
    getColumn(j: number): Vector<S>;
    getColumnVectors(): Vector<S>[];
    getDiagonal(): Vector<S>;
    getEntry(i: number, j: number): S;
    getNumberOfColumns(): number;
    getNumberOfRows(): number;
    getRow(i: number): Vector<S>;
    getRowVectors(): Vector<S>[];
    getSparseData(): Map<number, Map<number, S>>;
    multiply(other: Matrix<S>): Matrix<S>;
    abstract ops(): ScalarOperations<S>;
    scalarMultiply(scalar: S): Matrix<S>;
    set(i: number, j: number, value: S): Matrix<S>;
    toArray(): S[][];
    trace(): S;
    transpose(): Matrix<S>;
    abstract vectorBuilder(): VectorBuilder<S, Vector<S>>;
}

// @public
export type SparseMatrixData<S> = ReadonlyMap<number, ReadonlyMap<number, S>>;

// @public
export class SparseNumberMatrix extends SparseMatrix<number> {
    // @internal
    constructor(data: MatrixData<number>);
    // (undocumented)
    static builder(): MatrixBuilder<number, SparseNumberVector, SparseNumberMatrix>;
    builder(): MatrixBuilder<number, SparseNumberVector, SparseNumberMatrix>;
    // (undocumented)
    static ops(): ScalarOperations<number>;
    ops(): ScalarOperations<number>;
    // (undocumented)
    static vectorBuilder(): VectorBuilder<number, SparseNumberVector>;
    vectorBuilder(): VectorBuilder<number, SparseNumberVector>;
}

// @public
export class SparseNumberVector extends SparseVector<number> {
    // @internal
    constructor(data: VectorData<number>);
    // (undocumented)
    static builder(): VectorBuilder<number, SparseNumberVector>;
    // (undocumented)
    builder(): VectorBuilder<number, SparseNumberVector>;
    // (undocumented)
    matrixBuilder(): MatrixBuilder<number, SparseNumberVector, SparseNumberMatrix>;
    // (undocumented)
    static ops(): ScalarOperations<number>;
    // (undocumented)
    ops(): ScalarOperations<number>;
}

// @public
export abstract class SparseVector<S> implements Vector<S> {
    // @internal
    protected constructor(data: VectorData<S>);
    add(other: Vector<S>): Vector<S>;
    // (undocumented)
    abstract builder(): VectorBuilder<S, Vector<S>>;
    equals(other: Vector<S>): boolean;
    getDimension(): number;
    getEntry(index: number): S;
    getSparseData(): Map<number, S>;
    innerProduct(other: Vector<S>): S;
    // (undocumented)
    abstract matrixBuilder(): MatrixBuilder<S, Vector<S>, Matrix<S>>;
    // (undocumented)
    abstract ops(): ScalarOperations<S>;
    outerProduct(other: Vector<S>): Matrix<S>;
    projectOnto(u: Vector<S>): Vector<S>;
    scalarMultiply(scalar: S): Vector<S>;
    toArray(): S[];
}

// @public
export type SparseVectorData<S> = ReadonlyMap<number, S>;

// @public
export function sumNorm<S>(v: Vector<S>): number;

// @public
export function supremumNorm<S>(v: Vector<S>): number;

// @public
export function tripleProduct<S>(first: Vector<S>, second: Vector<S>, third: Vector<S>): S;

// @public
export interface Vector<S> {
    add(other: Vector<S>): Vector<S>;
    builder(): VectorBuilder<S, Vector<S>>;
    equals(other: Vector<S>): boolean;
    getDimension(): number;
    getEntry(index: number): S;
    getSparseData(): Map<number, S>;
    innerProduct(other: Vector<S>): S;
    matrixBuilder(): MatrixBuilder<S, Vector<S>, Matrix<S>>;
    ops(): ScalarOperations<S>;
    outerProduct(other: Vector<S>): Matrix<S>;
    projectOnto(u: Vector<S>): Vector<S>;
    scalarMultiply(scalar: S): Vector<S>;
    toArray(): S[];
}

// @public
export class VectorBuilder<S, V extends Vector<S>> {
    // @internal
    constructor(vectorConstructor: VectorConstructor<S, V>);
    concatenate(first: Vector<S>, second: Vector<S>): V;
    elementaryVector(dimension: number, oneIndex: number): V;
    empty(): V;
    fill(value: S, dimension: number): V;
    // (undocumented)
    fromArray(data: VectorData<S>): V;
    fromIndexFunction(dimension: number, valueFromIndex: VectorIndexFunction<S>): V;
    // (undocumented)
    fromNumberArray(data: VectorData<number>): V;
    // (undocumented)
    fromSparseData(dimension: number, sparseData: SparseVectorData<S>): V;
    // (undocumented)
    fromValues(...data: VectorData<S>): V;
    map(vector: Vector<S>, valueFromEntry: VectorEntryFunction<S>): V;
    ones(dimension: number): V;
    random(dimension: number, min?: number, max?: number): V;
    randomNormal(dimension: number, mean?: number, standardDeviation?: number): V;
    shift(vector: Vector<S>, offset?: number, reverse?: boolean): V;
    zeros(dimension: number): V;
}

// Warning: (ae-internal-missing-underscore) The name "VectorConstructor" should be prefixed with an underscore because the declaration is marked as @internal
// 
// @internal (undocumented)
export interface VectorConstructor<S, V extends Vector<S>> {
    // (undocumented)
    new (data: VectorData<S>): V;
    // (undocumented)
    builder(): VectorBuilder<S, V>;
    // (undocumented)
    ops(): ScalarOperations<S>;
}

// @public
export type VectorData<S> = readonly S[];

// @public
export type VectorEntryFunction<S> = (entry: S, index: number) => S;

// @public
export type VectorIndexFunction<S> = (index: number) => S;


// (No @packageDocumentation comment for this package)

```
