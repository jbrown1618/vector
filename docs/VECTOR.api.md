## API Report File for "@josh-brown/vector"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { ArrayMatrix as ArrayMatrix_2 } from '@lib/types/matrix/ArrayMatrix';
import { ArrayVector as ArrayVector_2 } from '@lib/types/vector/ArrayVector';
import { ComplexMatrix as ComplexMatrix_2 } from '@lib/types/matrix/ComplexMatrix';
import { ComplexNumber as ComplexNumber_2 } from '@lib/types/scalar/ComplexNumber';
import { ComplexNumberOperations as ComplexNumberOperations_2 } from '@lib/types/scalar/ComplexNumberOperations';
import { ComplexVector as ComplexVector_2 } from '@lib/types/vector/ComplexVector';
import { FloatMatrix as FloatMatrix_2 } from '@lib/types/matrix/FloatMatrix';
import { FloatVector as FloatVector_2 } from '@lib/types/vector/FloatVector';
import { GradientDescentRegressor } from '@lib/applications/machine-learning/models/GradientDescentRegressor';
import { LearningAlgorithm as LearningAlgorithm_2 } from '@lib/applications/machine-learning/LearningAlgorithm';
import { LinearSolution } from '@lib/solvers/LinearSolution';
import { LinearTransformation as LinearTransformation_2 } from '@lib/types/matrix/LinearTransformation';
import { Matrix as Matrix_2 } from '@lib/types/matrix/Matrix';
import { MatrixBuilder as MatrixBuilder_2 } from '@lib/types/matrix/MatrixBuilder';
import { MatrixConstructor as MatrixConstructor_2 } from '@lib/types/matrix/Matrix';
import { MatrixData as MatrixData_2 } from '@lib/types/matrix/Matrix';
import { MatrixEntryCallback as MatrixEntryCallback_2 } from '@lib/types/matrix/Matrix';
import { MatrixShape as MatrixShape_2 } from '@lib/types/matrix/Matrix';
import { NumberMatrix as NumberMatrix_2 } from '@lib/types/matrix/NumberMatrix';
import { NumberOperations as NumberOperations_2 } from '@lib/types/scalar/NumberOperations';
import { NumberVector as NumberVector_2 } from '@lib/types/vector/NumberVector';
import { ScalarOperations as ScalarOperations_2 } from '@lib/types/scalar/ScalarOperations';
import { SparseMatrix as SparseMatrix_2 } from '@lib/types/matrix/SparseMatrix';
import { SparseMatrixData as SparseMatrixData_2 } from '@lib/types/matrix/SparseMatrix';
import { SparseNumberMatrix as SparseNumberMatrix_2 } from '@lib/types/matrix/SparseNumberMatrix';
import { SparseNumberVector as SparseNumberVector_2 } from '@lib/types/vector/SparseNumberVector';
import { SparseVector as SparseVector_2 } from '@lib/types/vector/SparseVector';
import { SparseVectorData as SparseVectorData_2 } from '@lib/types/vector/SparseVector';
import { Vector as Vector_2 } from '@lib/types/vector/Vector';
import { VectorBuilder as VectorBuilder_2 } from '@lib/types/vector/VectorBuilder';
import { VectorConstructor as VectorConstructor_2 } from '@lib/types/vector/Vector';
import { VectorData as VectorData_2 } from '@lib/types/vector/Vector';

// @public
export type ApproximationFunction<S> = (input: Vector_2<S>) => S;

// @public
export type ApproximationFunctionTemplate<S> = (coefficients: Vector_2<S>) => ApproximationFunction<S>;

// @public
export abstract class ArrayMatrix<S> implements Matrix_2<S> {
    // @internal
    protected constructor(data: MatrixData_2<S>);
    add(other: Matrix_2<S>): Matrix_2<S>;
    adjoint(): Matrix_2<S>;
    apply(vector: Vector_2<S>): Vector_2<S>;
    abstract builder(): MatrixBuilder_2<S, Vector_2<S>, Matrix_2<S>>;
    equals(other: Matrix_2<S>): boolean;
    forEachEntry(cb: MatrixEntryCallback_2<S>): void;
    getColumn(j: number): Vector_2<S>;
    getColumnVectors(): Vector_2<S>[];
    getDiagonal(): Vector_2<S>;
    getEntry(i: number, j: number): S;
    getNumberOfColumns(): number;
    getNumberOfRows(): number;
    getRow(i: number): Vector_2<S>;
    getRowVectors(): Vector_2<S>[];
    getShape(): MatrixShape_2;
    getSparseData(): Map<number, Map<number, S>>;
    multiply(other: Matrix_2<S>): Matrix_2<S>;
    abstract ops(): ScalarOperations_2<S>;
    scalarMultiply(scalar: S): Matrix_2<S>;
    set(i: number, j: number, value: S): Matrix_2<S>;
    toArray(): S[][];
    trace(): S;
    transpose(): Matrix_2<S>;
    abstract vectorBuilder(): VectorBuilder_2<S, Vector_2<S>>;
}

// @public
export abstract class ArrayVector<S> implements Vector_2<S> {
    // @internal
    protected constructor(data: VectorData_2<S>);
    add(other: Vector_2<S>): Vector_2<S>;
    abstract builder(): VectorBuilder_2<S, Vector_2<S>>;
    equals(other: Vector_2<S>): boolean;
    getDimension(): number;
    getEntry(index: number): S;
    getSparseData(): Map<number, S>;
    innerProduct(other: Vector_2<S>): S;
    abstract matrixBuilder(): MatrixBuilder_2<S, Vector_2<S>, Matrix_2<S>>;
    abstract ops(): ScalarOperations_2<S>;
    outerProduct(other: Vector_2<S>): Matrix_2<S>;
    projectOnto(u: Vector_2<S>): Vector_2<S>;
    scalarMultiply(scalar: S): Vector_2<S>;
    set(index: number, value: S): Vector_2<S>;
    toArray(): S[];
}

// @public
export function backwardDifferenceMatrix(binCount: number): NumberMatrix_2;

// @public
export function calculateCholeskyDecomposition<S>(A: Matrix_2<S>): CholeskyDecomposition<S> | undefined;

// @public
export function calculateEigenvalues<S>(A: Matrix_2<S>, numIterations?: number): Vector_2<S>;

// @public
export function calculateGeneralLeastSquares<S>(dataPoints: Vector_2<S>[], functionTemplate: ApproximationFunctionTemplate<S>, numberOfTerms: number): LeastSquaresApproximation<S>;

// @public
export function calculateLinearLeastSquares<S>(dataPoints: Vector_2<S>[]): LeastSquaresApproximation<S>;

// @public
export function calculateLUDecomposition<S>(A: Matrix_2<S>): LUDecomposition<S>;

// @public
export function calculateQRDecomposition<S>(A: Matrix_2<S>): QRDecomposition<S>;

// @public
export function calculateSingularValueDecomposition<S>(A: Matrix_2<S>): SingularValueDecomposition<S>;

// @public
export function center<S>(x: Vector_2<S>): Vector_2<S>;

// @public
export function center<S>(A: Matrix_2<S>): Matrix_2<S>;

// @public
export function centralDifferenceMatrix(binCount: number): NumberMatrix_2;

// @public
export interface CholeskyDecomposition<S> {
    // (undocumented)
    L: Matrix_2<S>;
}

// @public
export function columnSumSupremumNorm<S>(A: Matrix_2<S>): number;

// @public
export class ComplexMatrix extends ArrayMatrix_2<ComplexNumber_2> {
    // @internal
    constructor(data: MatrixData_2<ComplexNumber_2>);
    // (undocumented)
    static builder(): MatrixBuilder_2<ComplexNumber_2, ComplexVector_2, ComplexMatrix>;
    builder(): MatrixBuilder_2<ComplexNumber_2, ComplexVector_2, ComplexMatrix>;
    // (undocumented)
    static ops(): ScalarOperations_2<ComplexNumber_2>;
    ops(): ScalarOperations_2<ComplexNumber_2>;
    // (undocumented)
    static vectorBuilder(): VectorBuilder_2<ComplexNumber_2, ComplexVector_2>;
    vectorBuilder(): VectorBuilder_2<ComplexNumber_2, ComplexVector_2>;
}

// @public
export class ComplexNumber {
    constructor(real: number, imaginary: number);
    // (undocumented)
    add(other: ComplexNumber): ComplexNumber;
    // (undocumented)
    conjugate(): ComplexNumber;
    // (undocumented)
    equals(other: ComplexNumber): boolean;
    // (undocumented)
    getAdditiveInverse(): ComplexNumber;
    // (undocumented)
    getImaginaryPart(): number;
    // (undocumented)
    getMultiplicativeInverse(): ComplexNumber | undefined;
    // (undocumented)
    getRealPart(): number;
    // (undocumented)
    static readonly I: ComplexNumber;
    // (undocumented)
    multiply(other: ComplexNumber): ComplexNumber;
    // (undocumented)
    static readonly NEG_ONE: ComplexNumber;
    // (undocumented)
    static readonly ONE: ComplexNumber;
    // (undocumented)
    static readonly ZERO: ComplexNumber;
}

// @public
export class ComplexNumberOperations extends ScalarOperations_2<ComplexNumber_2> {
    add(first: ComplexNumber_2, second: ComplexNumber_2): ComplexNumber_2;
    conjugate(scalar: ComplexNumber_2): ComplexNumber_2;
    equals(first: ComplexNumber_2, second: ComplexNumber_2): boolean;
    fromComplex(real: number, imag: number): ComplexNumber_2;
    fromNumber(num: number): ComplexNumber_2;
    getAdditiveIdentity(): ComplexNumber_2;
    getAdditiveInverse(scalar: ComplexNumber_2): ComplexNumber_2;
    getMultiplicativeIdentity(): ComplexNumber_2;
    getMultiplicativeInverse(scalar: ComplexNumber_2): ComplexNumber_2 | undefined;
    getPrincipalSquareRoot(x: ComplexNumber_2): ComplexNumber_2;
    multiply(first: ComplexNumber_2, second: ComplexNumber_2): ComplexNumber_2;
    norm(x: ComplexNumber_2): number;
    prettyPrint(x: ComplexNumber_2): string;
    random(min?: number, max?: number): ComplexNumber_2;
    randomNormal(mean?: number, standardDeviation?: number): ComplexNumber_2;
}

// @public
export class ComplexVector extends ArrayVector_2<ComplexNumber_2> {
    // @internal
    constructor(data: VectorData_2<ComplexNumber_2>);
    // (undocumented)
    static builder(): VectorBuilder_2<ComplexNumber_2, ComplexVector>;
    builder(): VectorBuilder_2<ComplexNumber_2, ComplexVector>;
    matrixBuilder(): MatrixBuilder_2<ComplexNumber_2, ComplexVector, ComplexMatrix_2>;
    // (undocumented)
    static ops(): ComplexNumberOperations_2;
    ops(): ComplexNumberOperations_2;
}

// @public
export function correlation<S>(first: Vector_2<S>, second: Vector_2<S>): S;

// @public
export function correlation<S>(A: Matrix_2<S>): Matrix_2<S>;

// @public
export interface Cost {
    // (undocumented)
    cost: number;
    // (undocumented)
    gradient: Vector_2<number>;
}

// @public
export type CostFunction = (theta: Vector_2<number>) => Cost;

// @public
export function covariance<S>(first: Vector_2<S>, second: Vector_2<S>): S;

// @public
export function covariance<S>(A: Matrix_2<S>): Matrix_2<S>;

// @public
export function crossProduct<S>(first: Vector_2<S>, second: Vector_2<S>): Vector_2<S>;

// @public
export function derivative(f: (x: number) => number, xMin: number, xMax: number, binCount: number): Vector_2<number>;

// @public
export function determinant<S>(matrix: Matrix_2<S>): S;

// @public
export function diag(elements: number[]): Matrix_2<number>;

// Warning: (ae-forgotten-export) The symbol "DimensionReductionType" needs to be exported by the entry point index.d.ts
//
// @public
export type DimensionReductionOptions = DimensionReductionType & {
    useCorrelation?: boolean;
};

// @public
export function eig<S>(A: Matrix_2<S>, numIterations?: number): EigenPair<S>[];

// @public
export interface EigenPair<S> {
    // (undocumented)
    eigenvalue: S;
    // (undocumented)
    eigenvector: Vector_2<S>;
}

// @public
export function euclideanNorm<S>(v: Vector_2<S>): number;

// @public
export function exp<S>(A: Matrix_2<S>, order?: number): Matrix_2<S>;

// @public
export function eye(size: number): Matrix_2<number>;

// @public
export class FloatMatrix implements Matrix_2<number> {
    // @internal
    constructor(data: MatrixData_2<number>);
    constructor(data: Float64Array, shape: MatrixShape_2);
    add(other: Matrix_2<number>): Matrix_2<number>;
    adjoint(): Matrix_2<number>;
    apply(vector: Vector_2<number>): Vector_2<number>;
    // (undocumented)
    static builder(): MatrixBuilder_2<number, FloatVector_2, FloatMatrix>;
    builder(): MatrixBuilder_2<number, FloatVector_2, FloatMatrix>;
    equals(other: Matrix_2<number>): boolean;
    forEachEntry(cb: MatrixEntryCallback_2<number>): void;
    getColumn(j: number): Vector_2<number>;
    getColumnVectors(): Vector_2<number>[];
    getDiagonal(): Vector_2<number>;
    getEntry(i: number, j: number): number;
    getNumberOfColumns(): number;
    getNumberOfRows(): number;
    getRow(i: number): Vector_2<number>;
    getRowVectors(): Vector_2<number>[];
    getShape(): MatrixShape_2;
    getSparseData(): Map<number, Map<number, number>>;
    multiply(other: Matrix_2<number>): Matrix_2<number>;
    // (undocumented)
    static ops(): ScalarOperations_2<number>;
    ops(): ScalarOperations_2<number>;
    scalarMultiply(scalar: number): Matrix_2<number>;
    set(i: number, j: number, value: number): Matrix_2<number>;
    toArray(): number[][];
    trace(): number;
    transpose(): Matrix_2<number>;
    // (undocumented)
    static vectorBuilder(): VectorBuilder_2<number, FloatVector_2>;
    vectorBuilder(): VectorBuilder_2<number, FloatVector_2>;
}

// @public
export class FloatVector implements Vector_2<number> {
    // @internal
    constructor(data: VectorData_2<number> | Float64Array);
    add(other: Vector_2<number>): Vector_2<number>;
    // (undocumented)
    static builder(): VectorBuilder_2<number, FloatVector>;
    builder(): VectorBuilder_2<number, FloatVector>;
    equals(other: Vector_2<number>): boolean;
    getDimension(): number;
    getEntry(index: number): number;
    getSparseData(): Map<number, number>;
    innerProduct(other: Vector_2<number>): number;
    matrixBuilder(): MatrixBuilder_2<number, FloatVector, FloatMatrix_2>;
    // (undocumented)
    static ops(): NumberOperations_2;
    ops(): NumberOperations_2;
    outerProduct(other: Vector_2<number>): Matrix_2<number>;
    projectOnto(u: Vector_2<number>): Vector_2<number>;
    scalarMultiply(scalar: number): Vector_2<number>;
    set(index: number, value: number): Vector_2<number>;
    toArray(): number[];
}

// @public
export function forwardDifferenceMatrix(binCount: number): NumberMatrix_2;

// @public
export function frobeniusNorm<S>(A: Matrix_2<S>): number;

// @public
export function getEigenvectorForEigenvalue<S>(A: Matrix_2<S>, lambda: S): Vector_2<S>;

// @public
export function gradientDescent(parameters: GradientDescentParameters): LearningAlgorithm_2;

// @public
export interface GradientDescentParameters {
    // (undocumented)
    alpha: number;
    // (undocumented)
    maxIterations?: number;
}

// @public
export function inverse<S>(matrix: Matrix_2<S>): Matrix_2<S> | undefined;

// @public
export function isHermitian<S>(matrix: Matrix_2<S>): boolean;

// @public
export function isIdentity<S>(matrix: Matrix_2<S>): boolean;

// @public
export function isLowerTriangular<S>(matrix: Matrix_2<S>): boolean;

// @public
export function isOrthogonal<S>(matrix: Matrix_2<S>): boolean;

// @public
export function isOrthonormal<S>(matrix: Matrix_2<S>): boolean;

// Warning: (ae-internal-missing-underscore) The name "isSparse" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export function isSparse<S>(vector: Vector_2<S>): vector is SparseVector<S>;

// @public
export function isSquare(matrix: Matrix_2<any>): boolean;

// @public
export function isSymmetric<S>(matrix: Matrix_2<S>): boolean;

// @public
export function isUpperTriangular<S>(matrix: Matrix_2<S>): boolean;

// @public
export type LearningAlgorithm = (initialTheta: Vector_2<number>, costFn: CostFunction) => Vector_2<number>;

// @public
export interface LeastSquaresApproximation<S> {
    approximationFunction: ApproximationFunction<S>;
    coefficients: Vector_2<S>;
}

// @public
export class LinearRegressor extends GradientDescentRegressor<LinearRegressorHyperparams> {
    // @internal
    protected calculateCost(data: Matrix_2<number>, target: Vector_2<number>, theta: Vector_2<number>): number;
    // @internal
    protected calculateGradient(data: Matrix_2<number>, target: Vector_2<number>, theta: Vector_2<number>): Vector_2<number>;
    // @internal
    protected makePredictions(data: Matrix_2<number>, theta: Vector_2<number>): Vector_2<number>;
}

// @public
export interface LinearRegressorHyperparams {
    lambda: number;
}

// @public
export interface LinearTransformation<V, U> {
    apply(vector: V): U;
}

// @public
export function linspace(xMin: number, xMax: number, binCount: number): NumberVector_2;

// @public
export interface LUDecomposition<S> {
    // (undocumented)
    L: Matrix_2<S>;
    // (undocumented)
    P: Matrix_2<S>;
    // (undocumented)
    U: Matrix_2<S>;
}

// @public
export function mat(data: number[][]): Matrix_2<number>;

// @public
export interface Matrix<S> extends LinearTransformation_2<Vector_2<S>, Vector_2<S>> {
    add(other: Matrix<S>): Matrix<S>;
    adjoint(): Matrix<S>;
    apply(vector: Vector_2<S>): Vector_2<S>;
    builder(): MatrixBuilder_2<S, Vector_2<S>, Matrix<S>>;
    equals(other: Matrix<S>): boolean;
    forEachEntry(callback: MatrixEntryCallback<S>): void;
    getColumn(j: number): Vector_2<S>;
    getColumnVectors(): Vector_2<S>[];
    getDiagonal(): Vector_2<S>;
    getEntry(i: number, j: number): S;
    getNumberOfColumns(): number;
    getNumberOfRows(): number;
    getRow(i: number): Vector_2<S>;
    getRowVectors(): Vector_2<S>[];
    getShape(): MatrixShape;
    getSparseData(): Map<number, Map<number, S>>;
    multiply(other: Matrix<S>): Matrix<S>;
    ops(): ScalarOperations_2<S>;
    scalarMultiply(scalar: S): Matrix<S>;
    set(i: number, j: number, value: S): Matrix<S>;
    toArray(): S[][];
    trace(): S;
    transpose(): Matrix<S>;
    vectorBuilder(): VectorBuilder_2<S, Vector_2<S>>;
}

// @public
export class MatrixBuilder<S, V extends Vector_2<S>, M extends Matrix_2<S>> {
    // @internal
    constructor(matrixConstructor: MatrixConstructor_2<S, V, M>);
    augment(left: Matrix_2<S>, right: Matrix_2<S>): M;
    block(grid: Matrix_2<S>[][]): M;
    blockDiagonal(matrices: Matrix_2<S>[]): M;
    circulant(vector: Vector_2<S>): M;
    diagonal(diagonalEntries: Vector_2<S>): M;
    empty(): M;
    exclude(matrix: Matrix_2<S>, rowToExclude: number, columnToExclude: number): M;
    fill(value: S, shape: MatrixShape_2): M;
    // (undocumented)
    fromArray(data: MatrixData_2<S>): M;
    fromColumnVectors(columns: Vector_2<S>[]): M;
    fromIndexFunction(shape: MatrixShape_2, indexFunction: MatrixIndexFunction<S>): M;
    // (undocumented)
    fromNumberArray(numberData: MatrixData_2<number>): M;
    fromRowVectors(rows: Vector_2<S>[]): M;
    // (undocumented)
    fromSparseData(shape: MatrixShape_2, sparseData: SparseMatrixData_2<S>): M;
    hankel(firstColumn: Vector_2<S>, lastRow?: Vector_2<S>): M;
    hilbert(size: number): M;
    identity(size: number): M;
    map(matrix: Matrix_2<S>, entryFunction: MatrixEntryFunction<S>): M;
    ones(shape: MatrixShape_2): M;
    pascal(size: number, upper?: boolean): M;
    pascalSymmetric(size: number): M;
    random(shape: MatrixShape_2, min?: number, max?: number): M;
    randomNormal(shape: MatrixShape_2, mean?: number, standardDeviation?: number): M;
    repeat(matrix: Matrix_2<S>, rows: number, columns: number): M;
    slice(matrix: Matrix_2<S>, rowStartIndex?: number, columnStartIndex?: number, rowEndIndex?: number, columnEndIndex?: number): M;
    toeplitz(firstColumn: Vector_2<S>, firstRow?: Vector_2<S>): M;
    tridiagonal(leftEntries: Vector_2<S>, diagonalEntries: Vector_2<S>, rightEntries: Vector_2<S>): M;
    zeros(shape: MatrixShape_2): M;
}

// Warning: (ae-internal-missing-underscore) The name "MatrixConstructor" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface MatrixConstructor<S, V extends Vector_2<S>, M extends Matrix<S>> {
    // (undocumented)
    new (data: MatrixData<S>): M;
    // (undocumented)
    builder(): MatrixBuilder_2<S, V, M>;
    // (undocumented)
    ops(): ScalarOperations_2<S>;
    // (undocumented)
    vectorBuilder(): VectorBuilder_2<S, V>;
}

// @public
export type MatrixData<S> = readonly VectorData_2<S>[];

// @public
export type MatrixEntryCallback<S> = (entry: S, rowIndex: number, columnIndex: number) => void;

// @public
export type MatrixEntryFunction<S> = (entry: S, i: number, j: number) => S;

// @public
export type MatrixIndexFunction<S> = (i: number, j: number) => S;

// @public
export type MatrixShape = [number, number];

// @public
export function mean<S>(x: Vector_2<S>): S;

// @public
export function mean<S>(A: Matrix_2<S>): Vector_2<S>;

// @public
export function normalize<S>(v: Vector_2<S>): Vector_2<S> | undefined;

// @public
export class NumberMatrix extends ArrayMatrix_2<number> {
    // @internal
    constructor(data: MatrixData_2<number>);
    // (undocumented)
    static builder(): MatrixBuilder_2<number, NumberVector_2, NumberMatrix>;
    builder(): MatrixBuilder_2<number, NumberVector_2, NumberMatrix>;
    // (undocumented)
    static ops(): ScalarOperations_2<number>;
    ops(): ScalarOperations_2<number>;
    // (undocumented)
    static vectorBuilder(): VectorBuilder_2<number, NumberVector_2>;
    vectorBuilder(): VectorBuilder_2<number, NumberVector_2>;
}

// @public
export class NumberOperations extends ScalarOperations_2<number> {
    add(first: number, second: number): number;
    conjugate(scalar: number): number;
    equals(first: number, second: number): boolean;
    fromNumber(num: number): number;
    getAdditiveIdentity(): number;
    getAdditiveInverse(x: number): number;
    getMultiplicativeIdentity(): number;
    getMultiplicativeInverse(x: number): number | undefined;
    getPrincipalSquareRoot(x: number): number | undefined;
    multiply(first: number, second: number): number;
    norm(x: number): number;
    prettyPrint(x: number): string;
    random(min?: number, max?: number): number;
    randomNormal(mean?: number, standardDeviation?: number): number;
}

// @public
export class NumberVector extends ArrayVector_2<number> {
    // @internal
    constructor(data: VectorData_2<number>);
    // (undocumented)
    static builder(): VectorBuilder_2<number, NumberVector>;
    builder(): VectorBuilder_2<number, NumberVector>;
    matrixBuilder(): MatrixBuilder_2<number, NumberVector, NumberMatrix_2>;
    // (undocumented)
    static ops(): NumberOperations_2;
    ops(): NumberOperations_2;
}

// @public
export function ones(entries: number): Vector_2<number>;

// @public
export function ones(shape: MatrixShape_2): Matrix_2<number>;

// @public
export function pca<S>(A: Matrix_2<S>, useCorrelation?: boolean): PrincipalComponentAnalysis<S>;

// @public
export function pNorm<S>(v: Vector_2<S>, p: number): number;

// @public
export function pow<S>(A: Matrix_2<S>, n: number): Matrix_2<S>;

// @public
export function prettyPrint(num: number): string;

// @public
export function prettyPrint<S>(vector: Vector_2<S>): string;

// @public
export function prettyPrint<S>(matrix: Matrix_2<S>): string;

// @public
export interface PrincipalComponentAnalysis<S> {
    coordinates: Matrix_2<S>;
    cumulativeProportions: S[];
    principalComponents: Vector_2<S>[];
    proportions: S[];
    variances: S[];
}

// @public
export interface QRDecomposition<S> {
    // (undocumented)
    Q: Matrix_2<S>;
    // (undocumented)
    R: Matrix_2<S>;
}

// @public
export function rank<S>(matrix: Matrix_2<S>): number;

// @public
export function reduceDimensions(A: Matrix_2<number>, options: DimensionReductionOptions): Matrix_2<number>;

// @public
export function reducedRowEchelonForm<S>(matrix: Matrix_2<S>): Matrix_2<S>;

// @public
export interface Regressor {
    predict(data: Matrix_2<number>): Vector_2<number>;
    train(data: Matrix_2<number>, target: Vector_2<number>): void;
}

// @public
export function rowEchelonForm<S>(matrix: Matrix_2<S>): Matrix_2<S>;

// @public
export interface RowOperationResult<S> {
    // (undocumented)
    operator: Matrix_2<S>;
    // (undocumented)
    result: Matrix_2<S>;
}

// @public
export class RowOperations {
    static addRowToRow<S>(matrix: Matrix_2<S>, targetRow: number, rowToAdd: number): Matrix_2<S>;
    static addScalarMultipleOfRowToRow<S>(matrix: Matrix_2<S>, targetRow: number, rowToAdd: number, scalar: S): Matrix_2<S>;
    static exchangeRows<S>(matrix: Matrix_2<S>, first: number, second: number): Matrix_2<S>;
    static multiplyRowByScalar<S>(matrix: Matrix_2<S>, rowIndex: number, scalar: S): Matrix_2<S>;
    static pivot<S>(matrix: Matrix_2<S>): RowOperationResult<S>;
}

// @public
export function rowSumSupremumNorm<S>(A: Matrix_2<S>): number;

// @public
export abstract class ScalarOperations<S> {
    abstract add(first: S, second: S): S;
    abstract conjugate(scalar: S): S;
    divide(numerator: S, denominator: S): S | undefined;
    abstract equals(first: S, second: S): boolean;
    fromComplex(real: number, imaginary: number): S;
    abstract fromNumber(num: number): S;
    abstract getAdditiveIdentity(): S;
    abstract getAdditiveInverse(x: S): S;
    abstract getMultiplicativeIdentity(): S;
    abstract getMultiplicativeInverse(x: S): S | undefined;
    abstract getPrincipalSquareRoot(x: S): S | undefined;
    abstract multiply(first: S, second: S): S;
    negativeOne(): S;
    abstract norm(x: S): number;
    one(): S;
    abstract prettyPrint(x: S): string;
    abstract random(min: number, max: number): S;
    abstract randomNormal(mean: number, standardDeviation: number): S;
    subtract(first: S, second: S): S;
    zero(): S;
}

// @public
export interface SingularValueDecomposition<S> {
    // (undocumented)
    Sigma: Matrix_2<S>;
    // (undocumented)
    U: Matrix_2<S>;
    // (undocumented)
    V: Matrix_2<S>;
}

// @public
export function solveByGaussianElimination<S>(A: Matrix_2<S>, b: Vector_2<S>): LinearSolution<S>;

// @public
export function solveOverdeterminedSystem<S>(A: Matrix_2<S>, b: Vector_2<S>): Vector_2<S>;

// @public
export abstract class SparseMatrix<S> implements Matrix_2<S> {
    // @internal
    protected constructor(data: MatrixData_2<S>);
    add(other: Matrix_2<S>): Matrix_2<S>;
    adjoint(): Matrix_2<S>;
    apply(vector: Vector_2<S>): Vector_2<S>;
    abstract builder(): MatrixBuilder_2<S, Vector_2<S>, Matrix_2<S>>;
    equals(other: Matrix_2<S>): boolean;
    forEachEntry(cb: MatrixEntryCallback_2<S>): void;
    getColumn(j: number): Vector_2<S>;
    getColumnVectors(): Vector_2<S>[];
    getDiagonal(): Vector_2<S>;
    getEntry(i: number, j: number): S;
    getNumberOfColumns(): number;
    getNumberOfRows(): number;
    getRow(i: number): Vector_2<S>;
    getRowVectors(): Vector_2<S>[];
    getShape(): MatrixShape_2;
    getSparseData(): Map<number, Map<number, S>>;
    multiply(other: Matrix_2<S>): Matrix_2<S>;
    abstract ops(): ScalarOperations_2<S>;
    scalarMultiply(scalar: S): Matrix_2<S>;
    set(i: number, j: number, value: S): Matrix_2<S>;
    toArray(): S[][];
    trace(): S;
    transpose(): Matrix_2<S>;
    abstract vectorBuilder(): VectorBuilder_2<S, Vector_2<S>>;
}

// @public
export type SparseMatrixData<S> = ReadonlyMap<number, ReadonlyMap<number, S>>;

// @public
export class SparseNumberMatrix extends SparseMatrix_2<number> {
    // @internal
    constructor(data: MatrixData_2<number>);
    // (undocumented)
    static builder(): MatrixBuilder_2<number, SparseNumberVector_2, SparseNumberMatrix>;
    builder(): MatrixBuilder_2<number, SparseNumberVector_2, SparseNumberMatrix>;
    // (undocumented)
    static ops(): ScalarOperations_2<number>;
    ops(): ScalarOperations_2<number>;
    // (undocumented)
    static vectorBuilder(): VectorBuilder_2<number, SparseNumberVector_2>;
    vectorBuilder(): VectorBuilder_2<number, SparseNumberVector_2>;
}

// @public
export class SparseNumberVector extends SparseVector_2<number> {
    // @internal
    constructor(data: VectorData_2<number>);
    // (undocumented)
    static builder(): VectorBuilder_2<number, SparseNumberVector>;
    // (undocumented)
    builder(): VectorBuilder_2<number, SparseNumberVector>;
    // (undocumented)
    matrixBuilder(): MatrixBuilder_2<number, SparseNumberVector, SparseNumberMatrix_2>;
    // (undocumented)
    static ops(): ScalarOperations_2<number>;
    // (undocumented)
    ops(): ScalarOperations_2<number>;
}

// @public
export abstract class SparseVector<S> implements Vector_2<S> {
    // @internal
    protected constructor(data: VectorData_2<S>);
    add(other: Vector_2<S>): Vector_2<S>;
    // (undocumented)
    abstract builder(): VectorBuilder_2<S, Vector_2<S>>;
    equals(other: Vector_2<S>): boolean;
    getDimension(): number;
    getEntry(index: number): S;
    getSparseData(): Map<number, S>;
    innerProduct(other: Vector_2<S>): S;
    // (undocumented)
    abstract matrixBuilder(): MatrixBuilder_2<S, Vector_2<S>, Matrix_2<S>>;
    // (undocumented)
    abstract ops(): ScalarOperations_2<S>;
    outerProduct(other: Vector_2<S>): Matrix_2<S>;
    projectOnto(u: Vector_2<S>): Vector_2<S>;
    scalarMultiply(scalar: S): Vector_2<S>;
    set(index: number, value: S): Vector_2<S>;
    toArray(): S[];
}

// @public
export type SparseVectorData<S> = ReadonlyMap<number, S>;

// @public
export function standardDeviation<S>(x: Vector_2<S>): S;

// @public
export function standardDeviation<S>(A: Matrix_2<S>): Vector_2<S>;

// @public
export function standardize<S>(x: Vector_2<S>): Vector_2<S>;

// @public
export function standardize<S>(A: Matrix_2<S>): Matrix_2<S>;

// @public
export function sumNorm<S>(v: Vector_2<S>): number;

// @public
export function supremumNorm<S>(v: Vector_2<S>): number;

// @public
export function tripleProduct<S>(first: Vector_2<S>, second: Vector_2<S>, third: Vector_2<S>): S;

// @public
export function variance<S>(x: Vector_2<S>): S;

// @public
export function variance<S>(A: Matrix_2<S>): Vector_2<S>;

// @public
export function vec(data: number[]): Vector_2<number>;

// @public
export interface Vector<S> {
    add(other: Vector<S>): Vector<S>;
    builder(): VectorBuilder_2<S, Vector<S>>;
    equals(other: Vector<S>): boolean;
    getDimension(): number;
    getEntry(index: number): S;
    getSparseData(): Map<number, S>;
    innerProduct(other: Vector<S>): S;
    matrixBuilder(): MatrixBuilder_2<S, Vector<S>, Matrix_2<S>>;
    ops(): ScalarOperations_2<S>;
    outerProduct(other: Vector<S>): Matrix_2<S>;
    projectOnto(u: Vector<S>): Vector<S>;
    scalarMultiply(scalar: S): Vector<S>;
    set(index: number, value: S): Vector<S>;
    toArray(): S[];
}

// @public
export class VectorBuilder<S, V extends Vector_2<S>> {
    // @internal
    constructor(vectorConstructor: VectorConstructor_2<S, V>);
    combine(first: Vector_2<S>, second: Vector_2<S>, combineEntries: (a: S, b: S) => S): Vector_2<S>;
    concatenate(first: Vector_2<S>, second: Vector_2<S>): V;
    elementaryVector(dimension: number, oneIndex: number): V;
    empty(): V;
    fill(value: S, dimension: number): V;
    // (undocumented)
    fromArray(data: VectorData_2<S>): V;
    fromIndexFunction(dimension: number, valueFromIndex: VectorIndexFunction<S>): V;
    // (undocumented)
    fromNumberArray(data: VectorData_2<number>): V;
    // (undocumented)
    fromSparseData(dimension: number, sparseData: SparseVectorData_2<S>): V;
    // (undocumented)
    fromValues(...data: VectorData_2<S>): V;
    map(vector: Vector_2<S>, valueFromEntry: VectorEntryFunction<S>): V;
    ones(dimension: number): V;
    random(dimension: number, min?: number, max?: number): V;
    randomNormal(dimension: number, mean?: number, standardDeviation?: number): V;
    shift(vector: Vector_2<S>, offset?: number, reverse?: boolean): V;
    zeros(dimension: number): V;
}

// Warning: (ae-internal-missing-underscore) The name "VectorConstructor" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface VectorConstructor<S, V extends Vector<S>> {
    // (undocumented)
    new (data: VectorData<S>): V;
    // (undocumented)
    builder(): VectorBuilder_2<S, V>;
    // (undocumented)
    ops(): ScalarOperations_2<S>;
}

// @public
export type VectorData<S> = readonly S[];

// @public
export type VectorEntryFunction<S> = (entry: S, index: number) => S;

// @public
export type VectorIndexFunction<S> = (index: number) => S;

// @public
export function zeros(entries: number): Vector_2<number>;

// @public
export function zeros(shape: MatrixShape_2): Matrix_2<number>;


// (No @packageDocumentation comment for this package)

```
